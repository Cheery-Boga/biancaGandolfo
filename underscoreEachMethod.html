// const game = {};

//one *rare* way to iterate thru an an object is using a for loop.
// const game = {};

// game.suspects = [];

// game.suspects.push({name: 'Rusty', color: 'orange'});
// game.suspects[1] = {name: "Miss Scarlet", color: 'red'};

  // for (let i=0; i < game.suspects.length; i++){
  //   console.log(game.suspects[i]);
  // }
 
// preferably, you will use a for-in loop to iterate thru an object.

// const game = {};

// game.suspects = [];

// game.suspects.push({name: 'Rusty', color: 'orange'});
// game.suspects[1] = {name: "Miss Scarlet", color: 'red'};


// this iterate thru the object

// for (let key in game) {
//   let element = game[key];
  // console.log(element);

// console.log('-------------------------');
//this iterates thru the elements of each element inside the array as found in the element of the object

//   for (let key in element){
//     let subElement = element[key];
//     //console.log(subElement);
//   };
// };

// game.suspects[0].guilty = true;
// game.suspects[1].guilty = false;
// game;

//First one extrapolotes the value, using the long form.the second example, uses destructuring. 

// const game = {};

// game.suspects = [];

// game.suspects.push({name: 'Rusty', color: 'orange'});

// game.suspects[1] = {name: "Miss Scarlet", color: 'red'};
// game;


// let orange = {color} = game.suspects[0].color;
// let red = {color} = game.suspects[1].color;
// console.log(orange, red);
//destructure this nested data structure into two variables, with the strings "red" and "orange";

// const game = {};

// game.suspects = [];

// game.suspects.push({name: 'Rusty', color: 'orange'});

// game.suspects[1] = {name: "Miss Scarlet", color: 'red'};
// game;



// const [orange, red] = [game.suspects[0].color, game.suspects[1].color];

// red;

//this is the optimized answer for destructuring the object with an array!!

// const [{color: firstColor}, {color: secondColor}] = game.suspects;

//the above elements are the saying the same thing as:

// const [{firstElement: firstColor}, {secondElement: secondColor}] = game.suspects; 

// firstColor;

//but we need to use the same name of the key. This is just to illustrate what is happening under the hood.

//Hydrate is a slang. it means to take in data (or even a VUE model from the backend) and transform it into a data structure, like a class or object.That's like hydrating it. 

//IN JS, a class is a function that returns an object, wheas we use the keyword, "new". In this case, the use of a JS class doesn't deal with the this keyword.
// function createSuspectObject(name){
//   return {
//     name: name,
//     color: name.split(' ')[1],
//     speak () {
//       console.log('My name is', name);
//     }
//   };
// };

// var suspects = ["Miss Scarlet", "Colonel Mustard", "Mr. White"];

// var suspectsList = [];

//using the traditional for-loop
// function createSuspectObject(name){
//   return {
//     name: name,
//     color: name.split(' ')[1],
//     speak () {
//       console.log('My name is', name);
//     }
//   };
// };

// var suspects = ["Miss Scarlet", "Colonel Mustard", "Mr. White"];

// var suspectsList = [];
// for (let i=0; i < suspects.length; i++) {
//   suspectsList.push(createSuspectObject(suspects[i]));

// }
// suspectsList;

// using the _.each() method. 
function createSuspectObject(name){
  return {
    name: name,
    color: name.split(' ')[1],
    speak () {
      console.log('My name is', name);
    }
  };
};

var suspects = ["Miss Scarlet", "Colonel Mustard", "Mr. White"];

var suspectsList = [];

_.each(suspects, function(name){
  let suspectsObj = createSuspectObject(name);
  suspectsList.push(suspectsObj);
});

//underscoreMap method;

const weapons = ['candlestick', 'lead pipe', 'revolver'];
const makeBroken = item => console.log(`Broken ${item});
 _.map(weapons, makeBroken); 
 
 //creating a new _.map function
 
 _.map = function (array, callback) {
	let storage = [];
	
	for (let i=0; i < array.length; i++) {
	storage.push(callback(array[i], i, array));
    }
	return storage;
}

_.map([1,2,3,4], function(element){
return element + 1;}) //=>[2,3,4,5];

//"functional programmers don't like loops, we like to use functions (map/each methods) that do the looping for us, so that we don't have to think about it"
//so we need to translate the for-loop, in the above example, into a for each function


_.map = function (array, callback) {
	let storage = [];
	
<!--
	for (let i=0; i < array.length; i++) {
	storage.push(callback(array[i], i, array));
    }
-->

_.each(array, function(value, index, array){
    storage.push(callback(value, index, array));  //even though the _.each NEVER returns anything, this stateement on line 179 returns whatever the callback returns should be pushed to our storage array
})
	return storage;
}
 

// this _.each completely replaces the for-loop in its entirety! 

//test case returns an array with [2,3,4]:

_.map([1,2,3], function (element) {
return element + 1; })








